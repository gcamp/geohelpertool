{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup React Project with Build Configuration",
        "description": "Initialize React project with build system to compile into single HTML file",
        "details": "Create React app using Vite or Create React App. Configure build process to bundle everything into a single index.html file using tools like webpack-bundle-analyzer and html-webpack-plugin with inlineSource option. Set up package.json with necessary dependencies including React, react-dom, and build tools. Configure bundler to inline all CSS and JS assets.",
        "testStrategy": "Verify build process creates single HTML file that runs in browser without external dependencies. Test file size is reasonable and all assets are properly inlined.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Base Map Component with MapLibre GL JS",
        "description": "Create interactive map component using MapLibre GL JS as full-screen background",
        "details": "Install MapLibre GL JS and react-map-gl. Create MapComponent that renders full-screen map using MapLibre GL JS (not Apple Maps as specified, since Apple Maps requires native iOS/macOS - MapLibre provides similar functionality). Configure map with default view, zoom controls, and proper styling. Set up map container with absolute positioning to fill viewport.",
        "testStrategy": "Verify map renders correctly, is interactive (pan/zoom), and fills entire viewport. Test on multiple browsers and screen sizes.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure MapLibre GL JS Dependencies",
            "description": "Install MapLibre GL JS and react-map-gl packages with proper TypeScript support",
            "dependencies": [],
            "details": "Install maplibre-gl and react-map-gl packages using npm/yarn. Add TypeScript types if needed. Configure package.json with correct versions. Import necessary CSS files for MapLibre GL JS styling.",
            "status": "done",
            "testStrategy": "Verify packages are installed correctly and can be imported without errors"
          },
          {
            "id": 2,
            "title": "Create Base MapComponent Structure",
            "description": "Create React component file with basic MapLibre GL JS map setup",
            "dependencies": [
              1
            ],
            "details": "Create MapComponent.tsx in appropriate components directory. Set up basic React component structure with proper imports for MapLibre GL JS. Define component props interface for future extensibility.",
            "status": "done",
            "testStrategy": "Component should render without errors and accept basic props"
          },
          {
            "id": 3,
            "title": "Implement Full-Screen Map Container",
            "description": "Configure map container with absolute positioning to fill entire viewport",
            "dependencies": [
              2
            ],
            "details": "Set up CSS styles for full-screen map container using absolute positioning (top: 0, left: 0, width: 100%, height: 100%). Ensure map fills entire viewport with no scrollbars. Handle responsive behavior for different screen sizes.",
            "status": "done",
            "testStrategy": "Map should fill entire browser window across different screen sizes"
          },
          {
            "id": 4,
            "title": "Configure Map with Default View and Styling",
            "description": "Set up map with default geographic view, map style, and initial zoom level",
            "dependencies": [
              3
            ],
            "details": "Configure map with appropriate default center coordinates (likely San Francisco Bay Area based on geo helper context). Set default zoom level (around 10-12 for city view). Configure map style URL using MapLibre GL JS compatible style (OpenStreetMap or similar free style).",
            "status": "done",
            "testStrategy": "Map should load with proper default view and styling without errors"
          },
          {
            "id": 5,
            "title": "Add Interactive Controls and Finalize Setup",
            "description": "Implement zoom controls, navigation controls, and ensure proper map interactivity",
            "dependencies": [
              4
            ],
            "details": "Add NavigationControl for zoom in/out and compass. Enable map interaction (pan, zoom, rotate). Configure proper event handlers for map interactions. Ensure smooth performance and proper touch/mouse support.",
            "status": "done",
            "testStrategy": "All map controls should work properly - zoom, pan, rotate, and navigation buttons should be functional"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Right Sidebar Layout and UI Structure",
        "description": "Build right sidebar overlay with layer management interface",
        "details": "Create Sidebar component positioned absolute/fixed on right side of map. Style with proper z-index to overlay map. Include instructions text about drag-and-drop and paste functionality. Design responsive layout that works on different screen sizes. Use CSS for rounded corners, proper spacing, and visual hierarchy.",
        "testStrategy": "Verify sidebar appears on top of map, is properly positioned, and instructions are clearly visible. Test responsiveness across different screen sizes.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Sidebar Component Structure",
            "description": "Create the foundational React component for the right sidebar with proper positioning and basic layout",
            "dependencies": [],
            "details": "Create a new Sidebar.jsx component with absolute/fixed positioning on the right side of the screen. Set up basic CSS classes for positioning, width, and initial styling. Include proper z-index to ensure it overlays the map component. Create the component shell with basic props and state management.",
            "status": "done",
            "testStrategy": "Unit tests for component rendering and basic positioning CSS classes"
          },
          {
            "id": 2,
            "title": "Implement Sidebar Overlay Styling and Z-Index Management",
            "description": "Style the sidebar with proper overlay behavior, rounded corners, spacing, and visual hierarchy",
            "dependencies": [
              1
            ],
            "details": "Add CSS styling for rounded corners, proper spacing, background color, and shadows. Implement z-index management to ensure sidebar appears above map but below modals. Create visual hierarchy with proper typography, padding, and color scheme. Add subtle animations for smooth appearance.",
            "status": "done",
            "testStrategy": "Visual regression tests and CSS unit tests for styling properties"
          },
          {
            "id": 3,
            "title": "Add Instructional Text and Content Areas",
            "description": "Create content sections within the sidebar including instructions for drag-and-drop and paste functionality",
            "dependencies": [
              2
            ],
            "details": "Add instructional text explaining drag-and-drop file upload and paste functionality. Create designated content areas for different types of instructions and future layer management controls. Implement proper text styling and layout for readability.",
            "status": "done",
            "testStrategy": "Content verification tests and accessibility testing for text readability"
          },
          {
            "id": 4,
            "title": "Implement Responsive Design and Mobile Optimization",
            "description": "Make the sidebar responsive across different screen sizes and devices",
            "dependencies": [
              3
            ],
            "details": "Add responsive CSS media queries to handle different screen sizes. On mobile devices, consider collapsible or slide-out behavior. Adjust width, positioning, and content layout for tablet and mobile viewports. Ensure touch-friendly interactions and proper spacing on smaller screens.",
            "status": "done",
            "testStrategy": "Responsive design tests across multiple screen sizes and device types"
          },
          {
            "id": 5,
            "title": "Integrate Sidebar with Main Map Layout",
            "description": "Connect the sidebar component to the main application and ensure proper layout integration",
            "dependencies": [
              4
            ],
            "details": "Import and integrate the Sidebar component into the main map application. Ensure proper layout flow and that the sidebar doesn't interfere with map interactions. Add toggle functionality if needed. Test sidebar behavior with different map states and ensure proper event handling.",
            "status": "done",
            "testStrategy": "Integration tests for sidebar-map interaction and layout flow testing"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement GeoJSON Data Parser and Validator",
        "description": "Create robust GeoJSON parsing with validation and partial GeoJSON support",
        "details": "Install geojson validation library. Create parseGeoJSON function that validates full GeoJSON objects and attempts to parse partial GeoJSON (geometry objects). Extract style properties from GeoJSON properties field (color, style, etc.). Handle common GeoJSON style schemas. Create error handling for invalid JSON and provide meaningful error messages.",
        "testStrategy": "Unit tests for valid GeoJSON parsing, partial GeoJSON parsing, style extraction, and error handling. Test with various GeoJSON samples including malformed data.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure GeoJSON validation library",
            "description": "Research and install appropriate GeoJSON validation library (e.g., geojson-validation, @turf/boolean-valid) and set up project dependencies",
            "dependencies": [],
            "details": "Evaluate available GeoJSON validation libraries for features like schema validation, geometry validation, and error reporting. Install chosen library and configure TypeScript definitions if needed. Document library choice and rationale.\n<info added on 2025-07-06T01:40:28.873Z>\nLibrary installation completed successfully. The selected libraries are:\n\n1. geojson-validation - Provides comprehensive schema validation for GeoJSON objects according to RFC 7946 specification\n2. @turf/boolean-valid - Handles geometry validation to ensure geometric validity and proper coordinate structures\n3. @types/geojson - Supplies TypeScript type definitions for type safety and development experience\n\nThese libraries work together to provide a complete validation solution covering both structural schema validation and geometric validity checks. The combination ensures robust validation capabilities for the parsing function implementation.\n</info added on 2025-07-06T01:40:28.873Z>",
            "status": "done",
            "testStrategy": "Verify library installation and basic validation functionality with simple test cases"
          },
          {
            "id": 2,
            "title": "Create core GeoJSON parsing function",
            "description": "Implement parseGeoJSON function that accepts JSON input and validates complete GeoJSON objects",
            "dependencies": [
              1
            ],
            "details": "Create function that accepts string or object input, parses JSON if needed, and validates against GeoJSON specification. Handle FeatureCollection, Feature, and Geometry objects. Return structured result with validation status and parsed data.\n<info added on 2025-07-06T01:42:07.976Z>\nImplementation completed successfully in src/utils/geoJsonParser.ts. The core parsing function validates both schema structure and geometry validity, supporting all three main GeoJSON object types (FeatureCollection, Feature, Geometry). Returns structured results containing validation status, parsed data, error messages, and geometry counts. Comprehensive error handling implemented for malformed JSON, invalid schemas, and geometry validation failures.\n</info added on 2025-07-06T01:42:07.976Z>",
            "status": "done",
            "testStrategy": "Unit tests with valid/invalid GeoJSON examples, edge cases for malformed JSON"
          },
          {
            "id": 3,
            "title": "Implement partial GeoJSON support",
            "description": "Extend parser to handle partial GeoJSON objects, specifically standalone geometry objects",
            "dependencies": [
              2
            ],
            "details": "Detect and handle cases where input is a geometry object without Feature wrapper. Attempt to construct valid GeoJSON structure from partial input. Maintain compatibility with existing full GeoJSON parsing.\n<info added on 2025-07-06T01:43:13.315Z>\nSuccessfully implemented partial GeoJSON parsing functionality. The parsePartialGeoJSON function now detects standalone geometry objects and automatically wraps them in proper Feature structures. Main parseGeoJSON function has been updated with fallback logic that attempts partial parsing when standard GeoJSON validation fails. All geometry types are supported including Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, and GeometryCollection. This enhancement maintains backward compatibility while extending parser capabilities to handle incomplete or non-standard GeoJSON inputs.\n</info added on 2025-07-06T01:43:13.315Z>",
            "status": "done",
            "testStrategy": "Test with various geometry types (Point, LineString, Polygon) as standalone objects"
          },
          {
            "id": 4,
            "title": "Extract and process style properties",
            "description": "Implement style property extraction from GeoJSON properties field with support for common styling schemas",
            "dependencies": [
              2
            ],
            "details": "Extract style-related properties (color, stroke, fill, opacity, weight, etc.) from GeoJSON Feature properties. Support common styling conventions (Mapbox, Leaflet, GeoJSON-CSS). Normalize style properties to consistent internal format.\n<info added on 2025-07-06T01:44:21.829Z>\nImplementation completed successfully. Added extractStyleProperties function in geohelpertool/geojson_parser.py that handles multiple styling conventions:\n\n- Standard GeoJSON styling properties (stroke, fill, stroke-width, etc.)\n- Mapbox GL JS conventions (paint properties like fill-color, line-color)\n- Leaflet conventions (color, weight, opacity, fillColor, fillOpacity)\n- Alternative naming patterns for broader compatibility\n\nThe function normalizes all style properties to a consistent internal format with standardized keys (strokeColor, fillColor, strokeWidth, strokeOpacity, fillOpacity, markerColor, markerSize). Both main parsing functions (parseGeoJSON and parsePartialGeoJSON) now integrate style extraction and include style properties in their ParseResult return objects. Style extraction is robust with proper type checking and fallback handling for missing or invalid properties.\n</info added on 2025-07-06T01:44:21.829Z>",
            "status": "done",
            "testStrategy": "Test style extraction with various GeoJSON features containing different style property formats"
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling",
            "description": "Create robust error handling system with meaningful error messages for all parsing failures",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement error classification for different failure types (invalid JSON, invalid GeoJSON schema, unsupported geometry types). Provide detailed error messages with context about what went wrong and suggestions for fixing. Include error codes for programmatic handling.\n<info added on 2025-07-06T01:46:10.275Z>\nImplementation completed successfully. Added comprehensive error handling infrastructure including ERROR_CODES constants for programmatic error identification, createErrorResult helper function for consistent error formatting, and getGeometryErrorSuggestion function for providing specific guidance on geometry-related issues. Enhanced all error scenarios in both parseGeoJSON and parsePartialGeoJSON functions with specific error codes, detailed explanations of what went wrong, and actionable suggestions to help users fix common problems like invalid JSON syntax, missing required GeoJSON properties, and unsupported geometry types.\n</info added on 2025-07-06T01:46:10.275Z>",
            "status": "done",
            "testStrategy": "Test error scenarios including malformed JSON, invalid coordinates, unsupported geometry types, and missing required properties"
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Multi-Format Data Parser System",
        "description": "Implement parsers for encoded polyline, WKT, and lat/lng lists with auto-detection",
        "details": "Install @mapbox/polyline and wkt libraries. Create parsePolyline function with unescape option (default enabled if string contains backslashes). Create parseWKT function using wkt library. Create parseLatLngList function with CSV-like parsing and auto-detection of separator (comma, semicolon, space). Implement data type auto-detection logic that tries JSON first, then other formats. Create utility to normalize all formats to GeoJSON.",
        "testStrategy": "Unit tests for each parser type, auto-detection logic, and normalization to GeoJSON. Test with various input formats and edge cases.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Required Libraries",
            "description": "Install @mapbox/polyline and wkt libraries and verify their availability",
            "dependencies": [],
            "details": "Run npm install @mapbox/polyline wkt to add the required dependencies. Verify installation by importing the libraries in a test file. Check library documentation for usage patterns and API methods.",
            "status": "done",
            "testStrategy": "Create a simple test file that imports both libraries and verifies they can be instantiated without errors"
          },
          {
            "id": 2,
            "title": "Implement parsePolyline Function",
            "description": "Create a function to parse encoded polyline strings with configurable unescape option",
            "dependencies": [
              1
            ],
            "details": "Implement parsePolyline function that uses @mapbox/polyline library. Add unescape parameter (default true if string contains backslashes). Handle edge cases like empty strings, malformed polylines, and invalid characters. Return normalized coordinate arrays.",
            "status": "done",
            "testStrategy": "Test with various polyline formats including escaped and unescaped strings, empty inputs, and malformed data"
          },
          {
            "id": 3,
            "title": "Implement parseWKT Function",
            "description": "Create a function to parse Well-Known Text (WKT) geometric data using the wkt library",
            "dependencies": [
              1
            ],
            "details": "Implement parseWKT function that uses the wkt library to parse WKT strings. Handle different WKT geometry types (POINT, LINESTRING, POLYGON, etc.). Add error handling for malformed WKT strings. Return parsed geometry objects in a consistent format.",
            "status": "done",
            "testStrategy": "Test with various WKT geometry types, malformed WKT strings, and edge cases like empty geometries"
          },
          {
            "id": 4,
            "title": "Implement parseLatLngList Function",
            "description": "Create a function to parse latitude/longitude coordinate lists with auto-detection of separators",
            "dependencies": [],
            "details": "Implement parseLatLngList function that can parse CSV-like coordinate data. Auto-detect separators (comma, semicolon, space). Handle different coordinate formats (lat,lng vs lng,lat). Parse multi-line coordinate lists. Add validation for coordinate ranges and formats.",
            "status": "done",
            "testStrategy": "Test with different separator types, coordinate orders, multi-line inputs, and invalid coordinate values"
          },
          {
            "id": 5,
            "title": "Implement Auto-Detection and GeoJSON Normalization",
            "description": "Create data type auto-detection logic and utility to normalize all formats to GeoJSON",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement auto-detection logic that tries JSON parsing first, then attempts other format parsers. Create utility function to convert all parsed formats to standardized GeoJSON format. Add comprehensive error handling and fallback mechanisms. Ensure consistent output structure regardless of input format.",
            "status": "done",
            "testStrategy": "Test with mixed input types, malformed data, and verify all outputs conform to GeoJSON specification"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Layer State Management",
        "description": "Create state management system for handling multiple layers with properties",
        "details": "Design layer state structure with id, data, color, visibility, type, and options. Use React useState or useReducer for layer management. Create functions for addLayer, removeLayer, toggleVisibility, updateColor, and updateOptions. Implement color palette system with emoji color pills (游댯, 游릭, 游댮, 游리, 游릮, 游). Create layer ID generation system.",
        "testStrategy": "Unit tests for all layer management functions. Test state updates, color assignment, and layer operations. Verify proper React state updates trigger re-renders.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Layer State Structure and Types",
            "description": "Create TypeScript interfaces and types for layer state management including Layer interface with id, data, color, visibility, type, and options properties",
            "dependencies": [],
            "details": "Define Layer interface with required fields: id (string), data (GeoJSON or similar), color (string with emoji values), visibility (boolean), type (enum for different layer types), and options (object for layer-specific settings). Create supporting types for LayerType enum, ColorPalette constants, and LayerOptions interface. Export all types for use across components.",
            "status": "done",
            "testStrategy": "Unit tests to verify type definitions compile correctly and interfaces match expected structure"
          },
          {
            "id": 2,
            "title": "Implement Layer ID Generation System",
            "description": "Create a utility function to generate unique layer IDs for new layers",
            "dependencies": [
              1
            ],
            "details": "Implement generateLayerId function that creates unique identifiers for layers. Use UUID v4 or timestamp-based approach with prefix (e.g., 'layer_' + timestamp + random). Ensure IDs are unique across all layers and handle edge cases for concurrent layer creation. Include validation to prevent duplicate IDs.",
            "status": "done",
            "testStrategy": "Unit tests to verify ID uniqueness, format consistency, and concurrent generation scenarios"
          },
          {
            "id": 3,
            "title": "Create Core Layer Management Functions",
            "description": "Implement addLayer, removeLayer, toggleVisibility, updateColor, and updateOptions functions for layer manipulation",
            "dependencies": [
              1,
              2
            ],
            "details": "Create layer management functions: addLayer (accepts layer data and auto-generates ID), removeLayer (by ID with validation), toggleVisibility (by ID), updateColor (by ID with emoji color validation), and updateOptions (by ID with partial options update). Include error handling for invalid IDs and state validation. Implement immutable state updates for React compatibility.",
            "status": "done",
            "testStrategy": "Unit tests for each function covering success cases, error handling, and state immutability verification"
          },
          {
            "id": 4,
            "title": "Implement Color Palette System",
            "description": "Create color palette system with emoji color pills (游댯, 游릭, 游댮, 游리, 游릮, 游) and color management utilities",
            "dependencies": [
              1
            ],
            "details": "Define COLOR_PALETTE constant with emoji colors mapped to hex/CSS values. Create getColorFromEmoji, getNextAvailableColor, and validateColor utility functions. Implement color cycling for automatic assignment to new layers. Include color accessibility considerations and ensure colors work well on maps.",
            "status": "done",
            "testStrategy": "Unit tests for color utilities, validation functions, and color cycling logic"
          },
          {
            "id": 5,
            "title": "Set Up React State Management with useReducer",
            "description": "Implement React state management using useReducer for layer state with actions and reducer logic",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create layerReducer with actions for ADD_LAYER, REMOVE_LAYER, TOGGLE_VISIBILITY, UPDATE_COLOR, and UPDATE_OPTIONS. Implement useLayerState custom hook that provides state and dispatch functions. Include initial state setup and action creators. Ensure reducer handles all edge cases and maintains immutable state updates.",
            "status": "done",
            "testStrategy": "Integration tests for useLayerState hook, reducer action handling, and state consistency across operations"
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Paste and Drag-Drop Data Input System",
        "description": "Implement paste and drag-drop functionality for adding new layers",
        "details": "Add paste event listener to document that captures clipboard data. Implement drag-and-drop event handlers (dragover, drop) on map container. Create file reading functionality for dropped files. Integrate with data parsers to process pasted/dropped content. Add visual feedback for drag-over states. Handle multiple files and text content appropriately.",
        "testStrategy": "Test paste functionality with various data formats. Test drag-drop with different file types. Verify proper error handling for unsupported formats and file reading errors.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Document Paste Event Listener",
            "description": "Add paste event listener to document that captures clipboard data and handles text/image content",
            "dependencies": [],
            "details": "Create paste event handler that listens for Ctrl+V/Cmd+V events globally. Extract text content from clipboard using clipboardData API. Handle different content types (text/plain, text/html, image files). Prevent default paste behavior when map is focused. Parse clipboard content and prepare for data processing pipeline.",
            "status": "done",
            "testStrategy": "Unit tests for paste event handling, clipboard data extraction, and content type detection. Integration tests for paste functionality with different data formats."
          },
          {
            "id": 2,
            "title": "Create Drag-and-Drop Event Handlers",
            "description": "Implement dragover, dragenter, dragleave, and drop event handlers on map container",
            "dependencies": [],
            "details": "Add drag event listeners to map container element. Implement dragover handler to prevent default and allow drop. Create dragenter/dragleave handlers for visual feedback states. Implement drop handler to capture dropped files and data. Handle dataTransfer object to extract files and text content. Ensure proper event propagation and preventDefault calls.",
            "status": "done",
            "testStrategy": "Unit tests for drag event handlers and dataTransfer processing. Integration tests with simulated drag-and-drop operations using different file types."
          },
          {
            "id": 3,
            "title": "Build File Reading Functionality",
            "description": "Create file reading system for processing dropped files of various formats",
            "dependencies": [
              2
            ],
            "details": "Implement FileReader API integration for reading dropped files. Support multiple file formats (CSV, JSON, GeoJSON, KML, GPX). Create file type detection based on extension and MIME type. Handle file reading errors and large files appropriately. Implement progress tracking for large file uploads. Convert file content to standardized format for parser integration.",
            "status": "done",
            "testStrategy": "Unit tests for file reading, type detection, and error handling. Integration tests with various file formats and sizes. Performance tests for large file processing."
          },
          {
            "id": 4,
            "title": "Integrate with Data Parsers",
            "description": "Connect paste and drag-drop functionality with existing data parsing system",
            "dependencies": [
              1,
              3
            ],
            "details": "Route processed clipboard and file content to appropriate data parsers. Implement format detection to choose correct parser (CSV, JSON, GeoJSON, etc.). Handle parsing errors and provide user feedback. Integrate parsed data with layer creation system. Ensure consistent data structure output regardless of input method (paste vs drag-drop).",
            "status": "done",
            "testStrategy": "Integration tests for parser routing and data processing. End-to-end tests from paste/drop to layer creation. Error handling tests for malformed data."
          },
          {
            "id": 5,
            "title": "Add Visual Feedback and Multi-Content Handling",
            "description": "Implement visual feedback for drag-over states and handle multiple files/content types",
            "dependencies": [
              2,
              4
            ],
            "details": "Create visual indicators for drag-over states (border highlight, overlay message). Implement drop zone styling and animations. Handle multiple file drops simultaneously. Add progress indicators for file processing. Create user feedback for successful/failed operations. Implement content type icons and preview functionality. Handle mixed content types (files + text) appropriately.",
            "status": "done",
            "testStrategy": "UI tests for visual feedback states and animations. Integration tests for multiple file handling. User experience tests for feedback and progress indicators."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Map Layer Rendering and Styling Logic",
        "description": "Create map layer rendering with single/multi-layer color logic",
        "details": "Implement layer rendering on MapLibre GL JS map. Create single-layer logic that uses GeoJSON style properties when available. Implement multi-layer logic that uses color pill selection for all layers. Add/remove map sources and layers dynamically. Handle different geometry types (Point, LineString, Polygon) with appropriate styling. Implement layer visibility toggling.",
        "testStrategy": "Test single layer rendering with and without GeoJSON styles. Test multi-layer rendering with color pill overrides. Verify layer visibility toggling and proper cleanup when layers are removed.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup MapLibre GL JS Map Integration",
            "description": "Initialize MapLibre GL JS map instance and establish basic map rendering infrastructure",
            "dependencies": [],
            "details": "Create map container, configure MapLibre GL JS with proper styling, setup event handlers, and establish the foundation for dynamic layer management. Include proper error handling and map initialization validation.",
            "status": "done",
            "testStrategy": "Unit tests for map initialization, integration tests for basic map rendering and event handling"
          },
          {
            "id": 2,
            "title": "Implement Dynamic Source and Layer Management",
            "description": "Create functions to dynamically add, remove, and update map sources and layers",
            "dependencies": [
              1
            ],
            "details": "Develop utility functions for managing MapLibre sources and layers. Include methods for adding GeoJSON sources, removing sources when no longer needed, and updating source data. Handle layer ordering and ensure proper cleanup of resources.",
            "status": "in-progress",
            "testStrategy": "Unit tests for source/layer CRUD operations, integration tests for multiple layer management scenarios"
          },
          {
            "id": 3,
            "title": "Create Geometry-Specific Styling Logic",
            "description": "Implement styling logic for different geometry types (Point, LineString, Polygon)",
            "dependencies": [
              2
            ],
            "details": "Create styling functions that handle Point (circle/symbol), LineString (line), and Polygon (fill) geometries. Each geometry type should have appropriate default styles and support for custom styling properties. Include support for different visualization modes.",
            "status": "pending",
            "testStrategy": "Unit tests for each geometry type styling, visual regression tests for different geometry combinations"
          },
          {
            "id": 4,
            "title": "Implement Single-Layer Style Property Logic",
            "description": "Create logic to apply GeoJSON feature properties as styling when rendering single layers",
            "dependencies": [
              3
            ],
            "details": "Parse GeoJSON feature properties and apply them as MapLibre layer styles. Handle color properties, stroke width, opacity, and other styling attributes. Include fallback styling when properties are missing and validation for property values.",
            "status": "pending",
            "testStrategy": "Unit tests for property parsing and style application, integration tests with various GeoJSON feature property combinations"
          },
          {
            "id": 5,
            "title": "Implement Multi-Layer Color Management and Visibility Controls",
            "description": "Create color pill selection system for multi-layer scenarios and implement layer visibility toggling",
            "dependencies": [
              4
            ],
            "details": "Develop color assignment logic for multiple layers using color pills/palette. Implement layer visibility toggle functionality with proper state management. Create UI controls for color selection and visibility management. Handle layer ordering and z-index management.",
            "status": "pending",
            "testStrategy": "Unit tests for color assignment and visibility logic, integration tests for multi-layer scenarios, end-to-end tests for user interactions"
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Layer Cards UI with Options and Controls",
        "description": "Create layer management cards in sidebar with color selection and data-specific options",
        "details": "Create LayerCard component with rounded corners containing: text field showing input data (truncated), color dropdown with emoji options, data-specific options (polyline unescape, lat/lng swap), visibility toggle checkbox. Style cards with proper spacing and visual hierarchy. Implement color selection dropdown with emoji color pills. Add data-specific option controls based on layer type.",
        "testStrategy": "Test layer card rendering for different data types. Verify color selection updates map styling. Test data-specific options functionality. Ensure UI is responsive and accessible.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Map View Auto-Adjustment and Bounds Calculation",
        "description": "Add automatic map view adjustment to show all visible layers with optimized bounds calculation",
        "details": "Create bounds calculation function that computes bounding box of all visible layers. Implement map.fitBounds() calls when layers are added/removed or visibility changes. Add memoization for performance optimization. Handle edge cases like single points, empty layers, and very large datasets. Implement smooth transitions for bounds changes. Add padding around bounds for better visualization.",
        "testStrategy": "Test bounds calculation with various geometry types and combinations. Verify map adjusts view when layers are added/removed. Test performance with complex geometries. Ensure smooth transitions and proper padding.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-03T15:11:59.471Z",
      "updated": "2025-07-06T12:23:13.410Z",
      "description": "Tasks for master context"
    }
  }
}